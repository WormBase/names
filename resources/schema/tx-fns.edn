[{:db/ident :wormbase.tx-fns/new-person
  :db/doc "Create a new person."
  :db/fn #db/fn
  {:lang "clojure"
   :params [db data]
   :code
   "(println \"TBD\")"}}

 {:db/ident :wormbase.tx-fns/deactivate-person
  :db/doc "Deactivate a person"
  :db/fn #db/fn
  {:lang "clojure"
   :params [db lookup-ref]
   :code
   "(when-let [person (d/entity db lookup-ref)]
      (let [active? (:person/active? person)]
        [[:db/cas lookup-ref :person/active? active? false]]))"}}

 {:db/ident :wormbase.tx-fns/latest-id
  :db/doc "Get the latest identifier for a given `ident`."
  :db/fn #db/fn
  {:params [db ident]
   :lang "clojure"
   :code
   "(d/q '[:find (max ?gid) .
           :in $ ?ident
           :where
           [?e ?ident ?gid]]
          (d/history db)
          ident))"}}

 {:db/ident :wormbase.tx-fns/latest-id-number
  :db/doc
  "Get the numeric suffix of the latest identifier for a given `ident`."
  :db/fn #db/fn
  {:params [db ident]
   :lang "clojure"
   :code
   "(if-not (d/entid db ident)
     (throw (ex-info \"Invalid ident\" {:ident ident}))
     (or (some->> (d/invoke db :wormbase.tx-fns/latest-id db ident)
                  (re-seq #\"0*(\\d+)\")
                  (flatten)
                  (last)
                  (read-string))
          0))"}}

 {:db/ident :wormbase.tx-fns/next-identifier
  :db/doc "Get the next sequential identifier for a given ident."
  :db/fn #db/fn
  {:params [db ident template]
   :lang "clojure"
   :code
   "(let [invoke (partial d/invoke db)
          last-id (invoke :wormbase.tx-fns/latest-id-number db ident)]
      (->> last-id inc (format template)))"}}

 {:db/ident :wormbase.tx-fns/gene-dbid-ref
  :db/doc "Return an identifier sutiable for inter-transaction referencing for new gene."
  :db/fn #db/fn
  {:lang "clojure"
   :params [db record]
   :code
   "(let [kwds (juxt :gene/sequence-name :gene/cgc-name)]
       (->> (kwds record)
            (filter identity)
            (first)))"}}

 {:db/ident :wormbase.tx-fns/new-unnamed-gene
  :db/doc "Create a new entity assigning an existing identifier."
  :db/fn #db/fn
  {:lang "clojure"
   :params [db data]
   :code
   "(let [invoke (partial d/invoke db)
          identifier (:gene/id data)
          species-lur (-> data :gene/species vec first)]
     [(-> data
          (assoc :gene/species species-lur)
          (assoc :gene/status :gene.status/live))])"}}

 {:db/ident :wormbase.tx-fns/new-gene
  :db/doc "Record a new WBGene."
  :db/fn #db/fn
  {:lang "clojure"
   :params [db data mint-new-id?]
   :code
   "(let [invoke (partial d/invoke db)
          ident :gene/id
          template (-> (d/entity db [:template/describes ident])
                       :template/format)
          new-gene-ref (invoke :wormbase.tx-fns/gene-dbid-ref db data)
          identify (fn [rec]
                     (let [gid (if mint-new-id?
                                 (invoke :wormbase.tx-fns/next-identifier
                                         db
                                         ident
                                         template)
                                 (:gene/id data))
                           species-lur (-> rec :gene/species vec first)]
                       (-> (assoc rec ident gid)
                           (assoc :gene/species species-lur)
                           (assoc :gene/status :gene.status/live))))
          new (-> data
                  identify
                  (assoc :db/id new-gene-ref))]
      [new])"}}

 {:db/ident :wormbase.tx-fns/resolve-refs
  :db/doc "Resolve references in a datomic entity mapping to numeric db ids in `em`."
  :db/fn #db/fn
  {:lang "clojure"
   :requires [[clojure.walk :as w]]
   :params [db em]
   :code
   "(w/prewalk
      (fn [x]
        (if (map? x)
          (reduce-kv (fn [m k v]
                       (cond
                         (and (map? v) (:db/id v))  (assoc m k (:db/id v))
                         (keyword? v) (d/entid db v)
                         :else (assoc m k v)))
                       {}
                       x)
          x))
       em)"}}

 {:db/ident :wormbase.tx-fns/collate-cas-batch
  :db/doc "Collate a collection of compare-and-swap operations."
  :db/fn #db/fn
  {:lang "clojure"
   :requires [[clojure.walk :as w]]
   :params [db entity data]
   :code
   "(let [resolve-refs (partial d/invoke
                                db
                                :wormbase.tx-fns/resolve-refs
                                db)
          eid (:db/id entity)
          e-keys (keys data)
          entity-map (d/pull db '[*] eid)
          new (resolve-refs data)
          res (some->> (map (fn [[k v]]
                              (let [old-v (k (resolve-refs entity-map))]
                               (when-not (or (nil? v)
                                             (= old-v v))
                                 [:db.fn/cas eid k old-v v])))
                             new)
                       (remove nil?))]
      res)"}}

 {:db/ident :wormbase.tx-fns/update-gene
  :db/doc "Update/add a names for given entity."
  :db/fn #db/fn
  {:lang "clojure"
   :params [db lur data]
   :code
   "(let [entity (d/entity db lur)
          eid (:db/id entity)
          collate-cas-batch (partial
                             d/invoke
                             db
                             :wormbase.tx-fns/collate-cas-batch
                             db
                             entity)
          tx-data (collate-cas-batch data)]
      tx-data)"}}

 {:db/ident :wormbase.tx-fns/merge-genes
  :db/doc "Merge gene `src` into gene `into`."
  :db/fn #db/fn
  {:lang "clojure"
   :params [db from-id into-id into-biotype]
   :code
   "(let [participants (->> [from-id into-id]
                            (interleave (repeat :gene/id))
                            (partition 2))]
       (let [[from into] (map #(d/entity db %) participants)]
         (when-let [deads (filter #(= (:gene/status %) :gene.status/dead)
                                  [from into])]
           (when-not (empty? deads)
             (throw (ex-info \"Both merge participants must be live\"
                             {:type :wormbase.db/conflict
                              :dead-genes (map :gene/id deads)}))))
         (when (some nil? [from into])
           (throw (ex-info \"Merge participant does not exist!\"
                            {:missing (remove (comp not nil?)
                                              (map :gene/id [from into]))
                             :type :wormbase.db/missing
                             :participants participants})))
          (let [entid (partial d/entid db)
                from-seq-name (:gene/sequence-name from)
                none? #(every? nil? %)
                uncloned-into? (none?
                                ((juxt :gene/biotype :gene/sequence-name)
                                 into))
                [sid tid] (map :db/id [from into])
                txes [[:db.fn/cas sid :gene/status
                                      (entid (:gene/status from))
                                      (entid :gene.status/dead)]
                      [:db.fn/cas tid :gene/biotype
                                      (entid (:gene/biotype into))
                                      (entid into-biotype)]]
                tx-data (if uncloned-into?
                          (-> txes
                              (conj
                               [:db/retract sid
                                :gene/sequence-name from-seq-name])
                              (conj
                               [:db.fn/cas tid
                                :gene/sequence-name nil from-seq-name]))
                          txes)]
             tx-data)))"}}

 {:db/ident :wormbase.tx-fns/split-gene
  :db/doc "Split gene `src` into a new gene."
  :db/fn #db/fn
  {:lang "clojure"
   :params [db gene-id data mint-new-product-id?]
   :code
   "(if-let [gene (d/entity db [:gene/id gene-id])]
      (if (= (:gene/status gene) :gene.status/dead)
        (throw (ex-info \"Cannot split, gene specified is dead.\"
                        {:gene-id gene-id
                         :type :wormbase.db/conflict}))
        (let [{biotype :gene/biotype product :product} data
              {p-seq-name :gene/sequence-name
               p-bt :gene/biotype
               pgid :gene/id} product
              entid (partial d/entid db)
              bt-id (entid biotype)
              src (d/entity db [:gene/id gene-id])
              existing-bt-id (-> src :gene/biotype entid)
              species (-> src :gene/species :species/id)
              new-gene-data (merge
                             {:gene/species {:species/id species}
                              :gene/biotype p-bt
                              :gene/sequence-name p-seq-name
                              :db/id p-seq-name}
                             (when pgid
                              {:gene/id pgid}))
              tx-data [[:db.fn/cas [:gene/id gene-id]
                                    :gene/biotype
                                    existing-bt-id
                                    bt-id]
                      [:wormbase.tx-fns/new-gene new-gene-data mint-new-product-id?]]]
           tx-data))
       (throw (ex-info \"Gene does not exist\"
                       {:gene-id gene-id
                        :type :wormbase.db/missing})))"}}

 {:db/ident :wormbase.tx-fns/set-many-ref
  :db/doc "Set the value for a cardinailty many reference."
  :db/fn #db/fn
  {:lang :clojure
   :params [db e attr new-vals]
   :code
   "(let [ent (or (d/entity db e)
                 (throw (ex-info "Entity not found" 
                                   {:type :wormbase.db/missing
                                    :e e :t (d/basis-t db)})))
         entid (:db/id ent)
         old-vals (get ent attr)]
     (into
      [{:db/id (:db/id ent) attr new-vals}]         ;; adding the new values
      ;; retracting the old values
      (comp (remove (set new-vals))
            (map (fn [v]
                   [:db/retract entid attr v])))
      old-vals)
     )"}}]
